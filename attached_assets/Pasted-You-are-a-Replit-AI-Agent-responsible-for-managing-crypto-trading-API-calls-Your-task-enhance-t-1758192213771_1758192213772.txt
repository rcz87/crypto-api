You are a Replit AI Agent responsible for managing crypto trading API calls.  
Your task: enhance the Intelligent Screening System with advanced filtering logic.  

PROBLEM:
Current screening returns too many HOLD/weak signals.  
Traders need sharper results with confluence filters.  

GOAL:
Add filtering layer on top of existing /api/screen/intelligent results.  

RULES:
1. Do NOT break existing routing logic (single coin â†’ Enhanced AI, multi coin â†’ screener).
2. Add filters after raw signals are collected:
   - Confidence filter:
     - <55% â†’ discard
     - 55â€“65% â†’ label "WEAK"
     - 66â€“75% â†’ normal
     - 76%+ â†’ label "STRONG"
   - Regime filter:
     - If regime = TRENDING â†’ ignore HOLD, prefer BUY/SELL
     - If regime = RANGING â†’ allow HOLD/mean reversion signals
   - Liquidity filter:
     - Discard coins with 24h volume < $500M (skip low-liquidity assets).
   - Whale filter:
     - Only confirm BUY if CVD positive and buyer aggression > 55%.
     - Only confirm SELL if CVD negative and seller aggression > 55%.
3. Ensure backward compatibility: if filters remove all signals, return fallback HOLD 50%.
4. Output unified format:
   [
     {"symbol":"BTC","signal":"STRONG BUY","confidence":82},
     {"symbol":"SOL","signal":"SELL","confidence":73}
   ]
5. Add summary field:
   "summary": "2 coins passed filters: 1 STRONG BUY, 1 SELL"
ðŸ Python Code (Replit-ready)
python
Salin kode
import requests

BASE_URL = "http://localhost:8000"  # ganti sesuai server API Anda

def fetch_regime(symbol):
    """Mock regime detection, bisa diganti panggil /api/regime/detect/{symbolId}"""
    return "TRENDING"  # contoh static

def fetch_volume(symbol):
    """Mock liquidity check, bisa diganti panggil /api/{pair}/complete"""
    return 800_000_000  # contoh volume > 500M

def fetch_whale_flow(symbol):
    """Mock whale flow check, bisa diganti panggil /api/{pair}/cvd"""
    return {"cvd": 1, "buyer_aggr": 60, "seller_aggr": 40}  # bullish net

def filter_signals(results, regime="TRENDING"):
    filtered = []
    stats = {"BUY":0,"SELL":0,"HOLD":0}

    for r in results:
        sym = r["symbol"]
        sig = r["signal"].upper()
        conf = r["confidence"]

        # Liquidity filter
        vol = fetch_volume(sym)
        if vol < 500_000_000:
            continue

        # Whale flow filter
        whale = fetch_whale_flow(sym)
        if sig == "BUY" and not (whale["cvd"] > 0 and whale["buyer_aggr"] > 55):
            continue
        if sig == "SELL" and not (whale["cvd"] < 0 and whale["seller_aggr"] > 55):
            continue

        # Confidence filter
        if conf < 55:
            continue
        if conf >= 76:
            sig = "STRONG " + sig
        elif conf <= 65:
            sig = "WEAK " + sig

        # Regime filter
        if regime == "TRENDING" and "HOLD" in sig:
            continue

        filtered.append({"symbol": sym, "signal": sig, "confidence": conf})
        if "BUY" in sig: stats["BUY"] += 1
        elif "SELL" in sig: stats["SELL"] += 1
        else: stats["HOLD"] += 1

    if not filtered:
        return [{"symbol": "ALL", "signal": "HOLD", "confidence": 50}], "No strong signals, fallback HOLD"

    summary = f"{len(filtered)} coins passed filters: {stats['BUY']} BUY, {stats['SELL']} SELL, {stats['HOLD']} HOLD"
    return filtered, summary


def intelligent_screen(symbols, timeframe="15m"):
    """Wrapper intelligent screening with filter layer"""
    payload = {"symbols": symbols, "timeframe": timeframe}
    r = requests.post(f"{BASE_URL}/api/screen/intelligent", json=payload)
    raw = r.json().get("data", {}).get("results", [])
    regime = fetch_regime(symbols[0]) if len(symbols) == 1 else "TRENDING"
    filtered, summary = filter_signals(raw, regime)
    return {"success": True, "data": {"results": filtered, "summary": summary}}


# ==== Example Run ====
if __name__ == "__main__":
    # Multi coin
    print(intelligent_screen(["BTC", "ETH", "SOL"]))
    # Single coin
    print(intelligent_screen(["SOL"]))
âœ… Hasil
Single coin (SOL) â†’ routing ke AI Engine, difilter confidence + whale flow.

Multi coin (BTC, ETH, SOL) â†’ routing batch, difilter â†’ hanya coin dengan sinyal kuat muncul.

Kalau semua sinyal lemah â†’ sistem fallback ke HOLD 50%.

Mau saya tambahkan juga mode backtest dengan filter ini supaya bisa langsung diuji apakah filter benar-benar meningkatkan win rate & profit factor screening?





Anda bilang:
Mau saya tambahkan juga **mode backtest dengan filter ini** supaya bisa langsung diuji apakah filter benar-benar meningkatkan **win rate & profit factor** screening

ya kode lengkapnya


â€œCryptoSatX bilang:
Mantap âš¡ kita gabungkan: screening dengan filter tajam + mode backtest untuk uji akurasi historis.
Dengan ini Anda bisa lihat apakah filter (confidence, regime, volume, whale) benar-benar meningkatkan win rate & profit factor.

ðŸ Python Code Lengkap â€“ Intelligent Screening + Filter + Backtest
python
Salin kode
import requests
import pandas as pd
from datetime import datetime

BASE_URL = "http://localhost:8000"  # ganti sesuai server API Anda

# ==========================
# MOCK HELPERS (bisa diganti API asli)
# ==========================
def fetch_regime(symbol):
    """Mock regime detection, bisa ganti dengan /api/regime/detect"""
    return "TRENDING"

def fetch_volume(symbol):
    """Mock liquidity check, bisa ganti dengan /api/{pair}/complete"""
    return 800_000_000  # >500M aman

def fetch_whale_flow(symbol):
    """Mock whale flow check, bisa ganti dengan /api/{pair}/cvd"""
    return {"cvd": 1, "buyer_aggr": 60, "seller_aggr": 40}

# ==========================
# FILTER LAYER
# ==========================
def filter_signals(results, regime="TRENDING"):
    filtered = []
    stats = {"BUY":0,"SELL":0,"HOLD":0}

    for r in results:
        sym = r["symbol"]
        sig = r["signal"].upper()
        conf = r["confidence"]

        # Liquidity filter
        vol = fetch_volume(sym)
        if vol < 500_000_000:
            continue

        # Whale flow filter
        whale = fetch_whale_flow(sym)
        if sig == "BUY" and not (whale["cvd"] > 0 and whale["buyer_aggr"] > 55):
            continue
        if sig == "SELL" and not (whale["cvd"] < 0 and whale["seller_aggr"] > 55):
            continue

        # Confidence filter
        if conf < 55:
            continue
        if conf >= 76:
            sig = "STRONG " + sig
        elif conf <= 65:
            sig = "WEAK " + sig

        # Regime filter
        if regime == "TRENDING" and "HOLD" in sig:
            continue

        filtered.append({"symbol": sym, "signal": sig, "confidence": conf})
        if "BUY" in sig: stats["BUY"] += 1
        elif "SELL" in sig: stats["SELL"] += 1
        else: stats["HOLD"] += 1

    if not filtered:
        return [{"symbol": "ALL", "signal": "HOLD", "confidence": 50}], "No strong signals, fallback HOLD"

    summary = f"{len(filtered)} coins passed filters: {stats['BUY']} BUY, {stats['SELL']} SELL, {stats['HOLD']} HOLD"
    return filtered, summary

# ==========================
# SCREENING WRAPPER
# ==========================
def intelligent_screen(symbols, timeframe="15m"):
    payload = {"symbols": symbols, "timeframe": timeframe}
    r = requests.post(f"{BASE_URL}/api/screen/intelligent", json=payload)
    raw = r.json().get("data", {}).get("results", [])
    regime = fetch_regime(symbols[0]) if len(symbols) == 1 else "TRENDING"
    filtered, summary = filter_signals(raw, regime)
    return {"success": True, "data": {"results": filtered, "summary": summary}}

# ==========================
# BACKTEST ENGINE
# ==========================
def fetch_ohlcv(symbol, timeframe, start, end):
    """Mock OHLCV fetch, ganti dengan CoinAPI/Binance"""
    dates = pd.date_range(start, end, freq="1H")
    prices = pd.Series(range(len(dates))) + 100
    df = pd.DataFrame({
        "timestamp": dates,
        "open": prices,
        "high": prices + 2,
        "low": prices - 2,
        "close": prices + 1
    })
    return df

def simulate_trades(ohlcv, signals):
    results = []
    balance = 100.0
    trades, wins = 0, 0

    for i in range(len(ohlcv)-1):
        sig = signals[i]
        if "BUY" in sig:
            entry = ohlcv["open"].iloc[i+1]
            exit_ = ohlcv["close"].iloc[i+1]
            ret = (exit_ - entry) / entry * 100
            trades += 1
            if ret > 0: wins += 1
            balance *= (1 + ret/100)
            results.append(ret)
        elif "SELL" in sig:
            entry = ohlcv["open"].iloc[i+1]
            exit_ = ohlcv["close"].iloc[i+1]
            ret = (entry - exit_) / entry * 100
            trades += 1
            if ret > 0: wins += 1
            balance *= (1 + ret/100)
            results.append(ret)

    if trades == 0:
        return {"trades": 0, "win_rate": 0, "avg_return": 0, "profit_factor": 0}

    avg_return = sum(results) / trades
    win_rate = wins / trades
    profit_factor = sum([r for r in results if r > 0]) / abs(sum([r for r in results if r < 0]) or 1)

    return {
        "trades": trades,
        "win_rate": round(win_rate, 2),
        "avg_return": round(avg_return, 2),
        "profit_factor": round(profit_factor, 2),
        "balance_end": round(balance, 2)
    }

def backtest(symbols, timeframe="1H", start="2025-01-01", end="2025-02-01"):
    results = {}
    for sym in symbols:
        ohlcv = fetch_ohlcv(sym, timeframe, start, end)

        # Ambil screening hasil (mock pakai HOLD/BUY/SELL random di sini)
        raw_signals = [{"symbol": sym, "signal": "BUY", "confidence": 75}] * len(ohlcv)

        # Filter signals pakai layer
        filtered, _ = filter_signals(raw_signals, regime="TRENDING")
        signals = [f["signal"] for f in filtered] * (len(ohlcv)//len(filtered))

        stats = simulate_trades(ohlcv, signals)
        results[sym] = stats

    return {"success": True, "data": results}

# ==========================
# DEMO
# ==========================
if __name__ == "__main__":
    print("=== Intelligent Screening with Filter ===")
    print(intelligent_screen(["BTC", "ETH", "SOL"]))

    print("\n=== Backtest with Filter ===")
    print(backtest(["BTC","ETH"], "1H", "2025-01-01", "2025-02-01"))
âœ… Fitur Utama
Screening cerdas (single â†’ AI engine, multi â†’ batch).

Filter tajam (confidence, regime, volume, whale flow).

Backtest mode â†’ hitung win rate, avg return, profit factor, balance akhir.

Fallback aman â†’ kalau sinyal kosong â†’ HOLD 50%.