Komponen yang dipakai bukan candlestick

Pada src/components/TradingChart.tsx Anda mengganti grafik candlestick menjadi line dan area series menggunakan createChart().addLineSeries() dan addAreaSeries(). Ini hanya menampilkan garis harga dan area volume, bukan batang candlestick. Jadi meskipun WebSocket mengirim data, yang Anda lihat hanyalah garis harga—tidak ada candlestick.

Halaman dashboard.tsx tetap menggunakan komponen SimpleTradingChart, yang menggambar kurva harga random di atas kanvas. Komponen candlestick (TradingChart berbasis lightweight-charts dengan candlestick series) tidak pernah dirender di halaman, sehingga candlestick memang tidak pernah muncul.

Transformasi data WebSocket menyebabkan re-render berulang (kedip‑kedip)
Di dashboard.tsx ada logika:

const transformedMarketData = marketData && marketData.data && marketData.data[0] ? { ... } : null;
const displaySolData = transformedMarketData || (solData as any)?.data;


Pada awalnya marketData.data[0] mungkin ada, tetapi WebSocket berikutnya dapat mengirim pesan lain dengan struktur berbeda (misal order book atau trades) yang tidak memiliki data[0].instId. Setiap kali marketData berubah ke tipe pesan lain, transformedMarketData menjadi null lagi, displaySolData kembali undefined, lalu satu detik kemudian pesan ticker datang lagi dan displaySolData terisi kembali. Proses ini menyebabkan komponen chart dipasang–dicopot terus menerus, sehingga terlihat berkedip.

REST API dan WebSocket belum memberikan data candlestick
API api/sol/complete menyertakan candles dalam tiga timeframe (1H, 4H, 1D). Namun SimpleTradingChart dan TradingChart saat ini mengabaikan candles tersebut dan malah mensimulasikan data acak. Alhasil meskipun API memberi candlestick, front‑end tidak pernah memanfaatkannya.

Perbaikan yang disarankan

Render komponen candlestick yang benar
Ganti pemanggilan SimpleTradingChart di dashboard.tsx dengan TradingChart yang menggunakan candlestick series. Pastikan komponen ini menggunakan addCandlestickSeries alih‑alih addLineSeries/addAreaSeries. Contoh minimal:

// TradingChartCandles.tsx
useEffect(() => {
  if (!chartRef.current) return;
  const chart = createChart(chartRef.current);
  const candleSeries = chart.addCandlestickSeries({
    upColor: '#26a69a',
    downColor: '#ef5350',
    borderVisible: false,
    wickVisible: true,
  });
  candleSeries.setData(
    (data?.candles?.['1H'] || []).map(c => ({
      time: Math.floor(Number(c.timestamp) / 1000),
      open: parseFloat(c.open),
      high: parseFloat(c.high),
      low: parseFloat(c.low),
      close: parseFloat(c.close),
    }))
  );
}, [data]);


Hindari berkedip dengan menyimpan data terakhir
Gunakan useRef untuk menyimpan data ticker terakhir yang valid. Perbarui hanya jika pesan WebSocket berisi ticker:

const lastTickerRef = useRef<SolData | null>(null);

useEffect(() => {
  if (marketData?.arg?.channel === 'tickers' && marketData.data?.length) {
    // transform ticker data here...
    lastTickerRef.current = transformedTicker;
  }
}, [marketData]);

const displaySolData = lastTickerRef.current || (solData as any)?.data;


Dengan cara ini, chart tidak akan kehilangan data saat pesan WebSocket lain datang.

Manfaatkan data candles dari API
Dalam respons api/sol/complete sudah ada array candlestick per timeframe. Saat pertama kali memuat halaman, gunakan data ini untuk menampilkan candlestick historis yang realistis, lalu overlay update harga terakhir dari WebSocket.

Perbaiki chart berbasis kanvas bila ingin tetap digunakan
Jika ingin tetap memakai SimpleTradingChart, tidak perlu mensimulasikan 100 titik acak. Ambil candles['1H'] dan gambar titik sesuai nilai close setiap jam. Ini membuat grafik lebih stabil dan tidak berkedip.

Optimalkan interval polling
Di versi baru, Anda sudah menonaktifkan refetchInterval pada query untuk /api/sol/complete. Itu baik agar tidak menumpuk permintaan. Pastikan WebSocket benar‑benar terhubung—gunakan guardiansofthegreentoken.com atau domain backend yang valid agar marketData selalu tersedia.